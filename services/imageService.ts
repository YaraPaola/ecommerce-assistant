
import { GoogleGenAI, Modality } from "@google/genai";
import { ImageFile } from "../types";

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// Helper function to convert AVIF/WebP images to JPEG
const convertImageToJPEG = async (image: ImageFile): Promise<{ base64: string; mimeType: string }> => {
    // If already a supported format, return as-is
    if (image.mimeType !== 'image/avif' && image.mimeType !== 'image/webp') {
        return { base64: image.base64, mimeType: image.mimeType };
    }

    try {
        const img = new Image();
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        await new Promise((resolve, reject) => {
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx?.drawImage(img, 0, 0);
                resolve(null);
            };
            img.onerror = reject;
            img.src = `data:${image.mimeType};base64,${image.base64}`;
        });
        
        const jpegData = canvas.toDataURL('image/jpeg', 0.9);
        const base64 = jpegData.split(',')[1];
        
        return { base64, mimeType: 'image/jpeg' };
    } catch (error) {
        console.error('Failed to convert image format:', error);
        throw new Error('Unable to convert image format. Please try with a different image.');
    }
};

export const enhanceImage = async (image: ImageFile, prompt: string, size: string): Promise<ImageFile> => {
    try {
        // Convert AVIF/WebP to JPEG if needed
        const { base64, mimeType } = await convertImageToJPEG(image);
        
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [
                    {
                        inlineData: {
                            data: base64,
                            mimeType: mimeType,
                        },
                    },
                    {
                        text: `Your primary goal is to replace the background of the provided product image based on the following prompt.

CRITICAL RULES:
1.  **Product Integrity:** This is the most important instruction. Do NOT change the product in the image. Its appearance, shape, lighting, and texture must remain completely unaltered. ONLY change the background.
2.  **Aspect Ratio:** The final output image's aspect ratio should be ${size}. If preserving the product's original shape conflicts with this aspect ratio, prioritize preserving the product's shape and use background padding to meet the aspect ratio.
3.  **No Distortion:** Under no circumstances should the product be stretched, cropped, or distorted in any way.

Background Prompt: "${prompt}"`,
                    },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        const imagePart = response.candidates?.[0]?.content?.parts.find(part => part.inlineData);

        if (imagePart?.inlineData) {
            return {
                id: crypto.randomUUID(),
                name: `enhanced_${size}_${image.name}`,
                base64: imagePart.inlineData.data,
                mimeType: imagePart.inlineData.mimeType,
                selected: true,
            };
        } else {
            throw new Error("No image was generated by the model.");
        }
    } catch (error) {
        console.error("Error enhancing image:", error);
        if (error instanceof Error) {
            throw new Error(`Gemini API error: ${error.message}`);
        }
        throw new Error("An unknown error occurred during image enhancement.");
    }
};

export const createImageMontage = async (images: ImageFile[], prompt: string, size: string): Promise<ImageFile> => {
    if (images.length < 2) {
        throw new Error("At least two images are required to create a montage.");
    }

    try {
        // Convert all images to JPEG if needed
        const convertedImages = await Promise.all(images.map(img => convertImageToJPEG(img)));
        
        const imageParts = convertedImages.map(({ base64, mimeType }) => ({
            inlineData: {
                data: base64,
                mimeType: mimeType,
            },
        }));

        const textPart = {
            text: `Your primary goal is to generate a single product montage image with an exact aspect ratio of ${size}.

Within that ${size} frame, your second task is to combine all products from the input images into one new, cohesive image, placed on a new background described in the prompt below.

CRITICAL INSTRUCTIONS:
1.  **Aspect Ratio:** The final output image's aspect ratio MUST BE exactly ${size}. This is the most important instruction.
2.  **Product Integrity:** Do not change the products themselves. Arrange them artistically.
3.  **Cohesion:** Ensure consistent lighting, shadows, and perspective across all products to make them look like they belong in the same scene.

Background Prompt: "${prompt}"`,
        };

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [
                    textPart,
                    ...imageParts
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        const imagePart = response.candidates?.[0]?.content?.parts.find(part => part.inlineData);

        if (imagePart?.inlineData) {
            return {
                id: crypto.randomUUID(),
                name: `montage_${size}_${images.length}_images.png`,
                base64: imagePart.inlineData.data,
                mimeType: imagePart.inlineData.mimeType, // The API usually returns PNG for composites
                selected: true,
            };
        } else {
            throw new Error("No image was generated by the model for the montage.");
        }
    } catch (error) {
        console.error("Error creating image montage:", error);
        if (error instanceof Error) {
            throw new Error(`Gemini API error: ${error.message}`);
        }
        throw new Error("An unknown error occurred during image montage creation.");
    }
};


export const changeImageColor = async (image: ImageFile, color: string): Promise<ImageFile> => {
     try {
        // Convert AVIF/WebP to JPEG if needed
        const { base64, mimeType } = await convertImageToJPEG(image);

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [
                    {
                        inlineData: {
                            data: base64,
                            mimeType: mimeType,
                        },
                    },
                    {
                        text: `Your task is to change the color of the main product in this image to '${color}'. Do not change anything else about the image, especially the background. The product itself must remain completely unaltered in its appearance, shape, lighting, or texture, except for its color. Return only the edited image.`,
                    },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        const imagePart = response.candidates?.[0]?.content?.parts.find(part => part.inlineData);

        if (imagePart?.inlineData) {
            return {
                id: crypto.randomUUID(),
                name: `recolored_${color.replace(/\s/g, '_')}_${image.name}`,
                base64: imagePart.inlineData.data,
                mimeType: imagePart.inlineData.mimeType,
                selected: true, // By default, the new image is selected
            };
        } else {
            throw new Error("The model did not return an image. It may have been unable to perform the color change.");
        }
    } catch (error) {
        console.error("Error changing image color:", error);
        if (error instanceof Error) {
            throw new Error(`Gemini API error: ${error.message}`);
        }
        throw new Error("An unknown error occurred while changing the image color.");
    }
};

export const removeObjectFromImage = async (image: ImageFile, eraserPath: {x: number, y: number}[]): Promise<ImageFile> => {
    try {
        // Convert AVIF/WebP to JPEG if needed
        const { base64, mimeType } = await convertImageToJPEG(image);

        // Create a mask from the eraser path
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) throw new Error("Could not create canvas context");

        // Set canvas size to match image
        const img = new Image();
        await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = `data:${mimeType};base64,${base64}`;
        });

        canvas.width = img.width;
        canvas.height = img.height;

        // Draw the original image
        ctx.drawImage(img, 0, 0);

        // Draw the eraser path as a mask (white = keep, black = remove)
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 20; // Fixed brush size for now
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (eraserPath.length > 0) {
            ctx.beginPath();
            ctx.moveTo(eraserPath[0].x * canvas.width, eraserPath[0].y * canvas.height);
            for (let i = 1; i < eraserPath.length; i++) {
                ctx.lineTo(eraserPath[i].x * canvas.width, eraserPath[i].y * canvas.height);
            }
            ctx.stroke();
        }

        // Get the mask data
        const maskData = canvas.toDataURL('image/png').split(',')[1];

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [
                    {
                        inlineData: {
                            data: base64,
                            mimeType: mimeType,
                        },
                    },
                    {
                        inlineData: {
                            data: maskData,
                            mimeType: 'image/png',
                        },
                    },
                    {
                        text: `Your task is to remove the objects or areas marked by the white mask (second image) from the original product image (first image).

CRITICAL RULES:
1. **Product Integrity:** Do NOT change the main product in the image. Only remove the masked areas and intelligently fill them with appropriate background content.
2. **Seamless Integration:** The removed areas should be filled with content that matches the surrounding background seamlessly.
3. **No Artifacts:** Ensure there are no visible seams, edges, or artifacts where the removal occurred.
4. **Context Awareness:** Fill the removed areas with content that makes sense for the image context (e.g., if it's a product on a table, fill with more table surface).

Return only the cleaned image with the masked areas removed and filled.`,
                    },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        const imagePart = response.candidates?.[0]?.content?.parts.find(part => part.inlineData);

        if (imagePart?.inlineData) {
            return {
                id: crypto.randomUUID(),
                name: `cleaned_${image.name}`,
                base64: imagePart.inlineData.data,
                mimeType: imagePart.inlineData.mimeType,
                selected: true,
            };
        } else {
            throw new Error("The model did not return an image. It may have been unable to perform the object removal.");
        }
    } catch (error) {
        console.error("Error removing object from image:", error);
        if (error instanceof Error) {
            throw new Error(`Gemini API error: ${error.message}`);
        }
        throw new Error("An unknown error occurred while removing the object from the image.");
    }
};
