
import { GoogleGenAI, Modality } from "@google/genai";
import { ImageFile } from "../types";

const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

// Helper function to convert AVIF/WebP images to JPEG
const convertImageToJPEG = async (image: ImageFile): Promise<{ base64: string; mimeType: string }> => {
    // If already a supported format, return as-is
    if (image.mimeType !== 'image/avif' && image.mimeType !== 'image/webp') {
        return { base64: image.base64, mimeType: image.mimeType };
    }

    try {
        const img = new Image();
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        await new Promise((resolve, reject) => {
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx?.drawImage(img, 0, 0);
                resolve(null);
            };
            img.onerror = reject;
            img.src = `data:${image.mimeType};base64,${image.base64}`;
        });
        
        const jpegData = canvas.toDataURL('image/jpeg', 0.9);
        const base64 = jpegData.split(',')[1];
        
        return { base64, mimeType: 'image/jpeg' };
    } catch (error) {
        console.error('Failed to convert image format:', error);
        throw new Error('Unable to convert image format. Please try with a different image.');
    }
};

export const enhanceImage = async (image: ImageFile, prompt: string, size: string): Promise<ImageFile> => {
    try {
        // Convert AVIF/WebP to JPEG if needed
        const { base64, mimeType } = await convertImageToJPEG(image);
        
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [
                    {
                        inlineData: {
                            data: base64,
                            mimeType: mimeType,
                        },
                    },
                    {
                        text: `Your primary goal is to replace the background of the provided product image based on the following prompt.

CRITICAL RULES:
1.  **Product Integrity:** This is the most important instruction. Do NOT change the product in the image. Its appearance, shape, lighting, and texture must remain completely unaltered. ONLY change the background.
2.  **Aspect Ratio:** The final output image's aspect ratio should be ${size}. If preserving the product's original shape conflicts with this aspect ratio, prioritize preserving the product's shape and use background padding to meet the aspect ratio.
3.  **No Distortion:** Under no circumstances should the product be stretched, cropped, or distorted in any way.

Background Prompt: "${prompt}"`,
                    },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        const imagePart = response.candidates?.[0]?.content?.parts.find(part => part.inlineData);

        if (imagePart?.inlineData) {
            return {
                id: crypto.randomUUID(),
                name: `enhanced_${size}_${image.name}`,
                base64: imagePart.inlineData.data,
                mimeType: imagePart.inlineData.mimeType,
                selected: true,
            };
        } else {
            throw new Error("No image was generated by the model.");
        }
    } catch (error) {
        console.error("Error enhancing image:", error);
        if (error instanceof Error) {
            throw new Error(`Gemini API error: ${error.message}`);
        }
        throw new Error("An unknown error occurred during image enhancement.");
    }
};

export const createImageMontage = async (images: ImageFile[], prompt: string, size: string): Promise<ImageFile> => {
    if (images.length < 2) {
        throw new Error("At least two images are required to create a montage.");
    }

    try {
        // Convert all images to JPEG if needed
        const convertedImages = await Promise.all(images.map(img => convertImageToJPEG(img)));
        
        const imageParts = convertedImages.map(({ base64, mimeType }) => ({
            inlineData: {
                data: base64,
                mimeType: mimeType,
            },
        }));

        const textPart = {
            text: `Your primary goal is to generate a single product montage image with an exact aspect ratio of ${size}.

Within that ${size} frame, your second task is to combine all products from the input images into one new, cohesive image, placed on a new background described in the prompt below.

CRITICAL INSTRUCTIONS:
1.  **Aspect Ratio:** The final output image's aspect ratio MUST BE exactly ${size}. This is the most important instruction.
2.  **Product Integrity:** Do not change the products themselves. Arrange them artistically.
3.  **Cohesion:** Ensure consistent lighting, shadows, and perspective across all products to make them look like they belong in the same scene.

Background Prompt: "${prompt}"`,
        };

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [
                    textPart,
                    ...imageParts
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        const imagePart = response.candidates?.[0]?.content?.parts.find(part => part.inlineData);

        if (imagePart?.inlineData) {
            return {
                id: crypto.randomUUID(),
                name: `montage_${size}_${images.length}_images.png`,
                base64: imagePart.inlineData.data,
                mimeType: imagePart.inlineData.mimeType, // The API usually returns PNG for composites
                selected: true,
            };
        } else {
            throw new Error("No image was generated by the model for the montage.");
        }
    } catch (error) {
        console.error("Error creating image montage:", error);
        if (error instanceof Error) {
            throw new Error(`Gemini API error: ${error.message}`);
        }
        throw new Error("An unknown error occurred during image montage creation.");
    }
};


export const changeImageColor = async (image: ImageFile, color: string): Promise<ImageFile> => {
     try {
        // Convert AVIF/WebP to JPEG if needed
        const { base64, mimeType } = await convertImageToJPEG(image);

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [
                    {
                        inlineData: {
                            data: base64,
                            mimeType: mimeType,
                        },
                    },
                    {
                        text: `Your task is to change the color of the main product in this image to '${color}'. Do not change anything else about the image, especially the background. The product itself must remain completely unaltered in its appearance, shape, lighting, or texture, except for its color. Return only the edited image.`,
                    },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        const imagePart = response.candidates?.[0]?.content?.parts.find(part => part.inlineData);

        if (imagePart?.inlineData) {
            return {
                id: crypto.randomUUID(),
                name: `recolored_${color.replace(/\s/g, '_')}_${image.name}`,
                base64: imagePart.inlineData.data,
                mimeType: imagePart.inlineData.mimeType,
                selected: true, // By default, the new image is selected
            };
        } else {
            throw new Error("The model did not return an image. It may have been unable to perform the color change.");
        }
    } catch (error) {
        console.error("Error changing image color:", error);
        if (error instanceof Error) {
            throw new Error(`Gemini API error: ${error.message}`);
        }
        throw new Error("An unknown error occurred while changing the image color.");
    }
};

export const removeObjectFromImage = async (image: ImageFile, eraserPath: {x: number, y: number}[]): Promise<ImageFile> => {
    try {
        // Use Gemini AI for intelligent object removal and inpainting
        const { base64, mimeType } = await convertImageToJPEG(image);

        // Create a mask from the eraser path
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) throw new Error("Could not create canvas context");

        // Set canvas size to match image
        const img = new Image();
        await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = `data:${mimeType};base64,${base64}`;
        });

        canvas.width = img.width;
        canvas.height = img.height;

        // Create mask (white = areas to remove, black = keep)
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = 'white';
        ctx.lineWidth = Math.max(20, Math.min(img.width, img.height) / 20); // Responsive brush size
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (eraserPath.length > 0) {
            ctx.beginPath();
            ctx.moveTo(eraserPath[0].x * canvas.width, eraserPath[0].y * canvas.height);
            for (let i = 1; i < eraserPath.length; i++) {
                ctx.lineTo(eraserPath[i].x * canvas.width, eraserPath[i].y * canvas.height);
            }
            ctx.stroke();

            console.log(`ðŸŽ¨ Mask created: ${eraserPath.length} points, canvas ${canvas.width}x${canvas.height}, brush width ${ctx.lineWidth}px`);

            // Debug: Show the mask in a new window/tab (optional - comment out in production)
            // const maskWindow = window.open();
            // if (maskWindow) {
            //     maskWindow.document.write(`<img src="${canvas.toDataURL()}" />`);
            // }
        }

        const maskData = canvas.toDataURL('image/png').split(',')[1];

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [
                    {
                        text: `I will provide you with two images:
1. The ORIGINAL image (a product photo)
2. A MASK image showing WHITE areas on a BLACK background

Your task: Generate a new version of the original image where the WHITE areas in the mask have been removed and intelligently filled with appropriate background content.

CRITICAL INSTRUCTIONS:
1. **Identify Mask Areas:** Look at the second image (the mask). The WHITE pixels indicate areas to remove from the first image.
2. **Remove and Fill:** In the original image, remove/erase the areas corresponding to the white mask pixels, and intelligently fill those areas with background content that seamlessly matches the surrounding environment.
3. **Product Integrity:** If the main product is NOT marked for removal, keep it exactly as-is. Only modify the masked areas.
4. **Seamless Inpainting:** Fill removed areas with textures, colors, and patterns that blend naturally with the surrounding background (e.g., continue table surface, wall texture, floor patterns, etc.).
5. **No Artifacts:** Ensure smooth transitions with no visible seams, edges, or artifacts.
6. **Preserve Quality:** Maintain the original image's resolution, lighting, and overall quality.

Return ONLY the edited image with the masked areas removed and filled.`,
                    },
                    {
                        inlineData: {
                            data: base64,
                            mimeType: mimeType,
                        },
                    },
                    {
                        inlineData: {
                            data: maskData,
                            mimeType: 'image/png',
                        },
                    },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        const imagePart = response.candidates?.[0]?.content?.parts.find(part => part.inlineData);

        if (imagePart?.inlineData) {
            return {
                id: crypto.randomUUID(),
                name: `cleaned_${image.name}`,
                base64: imagePart.inlineData.data,
                mimeType: imagePart.inlineData.mimeType,
                selected: true,
            };
        } else {
            throw new Error("The AI model did not return an image. It may have been unable to perform the object removal.");
        }

    } catch (error) {
        console.error("Error removing object from image:", error);
        if (error instanceof Error) {
            throw new Error(`Gemini API error: ${error.message}`);
        }
        throw new Error("An unknown error occurred while removing the object from the image.");
    }
};
